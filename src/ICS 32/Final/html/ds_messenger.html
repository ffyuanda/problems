<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>ds_messenger API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ds_messenger</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import socket
import json
import time
from collections import namedtuple

test_mode = False
PORT = 3021
HOST = &#34;168.235.86.101&#34;
DataTuple = namedtuple(&#39;DataTuple&#39;, [&#39;type&#39;, &#39;message&#39;, &#39;token&#39;])


class DMProtocolError(Exception):
    &#34;&#34;&#34;
    Custom error class for DMProtocolError
    &#34;&#34;&#34;
    pass


class DirectMessengerError(Exception):
    &#34;&#34;&#34;
    Custom error class for DirectMessenger
    &#34;&#34;&#34;
    pass


class DirectMessage:
    &#34;&#34;&#34;
    The DirectMessage object using in sending messages.
    &#34;&#34;&#34;
    def __init__(self):
        self.recipient = None
        self.message = None
        self.timestamp = None

    def get_recipient(self):
        &#34;&#34;&#34;
        Get self.recipient
        :return: self.recipient
        &#34;&#34;&#34;
        return self.recipient

    def get_message(self):
        &#34;&#34;&#34;
        Get self.message
        :return: self.message
        &#34;&#34;&#34;
        return self.message

    def get_timestamp(self):
        &#34;&#34;&#34;
        Get self.timestamp
        :return: self.timestamp
        &#34;&#34;&#34;
        return self.timestamp

    def set_recipient(self, name) -&gt; None:
        &#34;&#34;&#34;
        Set self.recipient
        :return: None
        &#34;&#34;&#34;
        self.recipient = name

    def set_message(self, msg) -&gt; None:
        &#34;&#34;&#34;
        Set self.message
        :return: None
        &#34;&#34;&#34;
        self.message = msg

    def set_timestamp(self, time) -&gt; None:
        &#34;&#34;&#34;
        Set self.timestamp
        :return: None
        &#34;&#34;&#34;
        self.timestamp = time


class DirectMessenger:
    &#34;&#34;&#34;
    The class responsible for sending and receiving messages to and from another
    user.
    &#34;&#34;&#34;
    def __init__(self, dsuserver: str = None, username: str = None, password: str = None):
        self.token = None
        self.dsuserver = dsuserver
        self.username = username
        self.password = password
        # DMProtocol for usage
        self.protocol = DMProtocol()
        # Initialize the sock along with the DirectMessenger object
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            self.sock.connect((str(self.dsuserver), PORT))
        except socket.gaierror as e:
            msg = &#39;The address or port seems incorrect&#39;
            raise DirectMessengerError(msg) from e

    def send(self, message: str, recipient: str) -&gt; bool:
        &#34;&#34;&#34;
        Send the message to the specified recipient.
        Returns true if message successfully sent, false if send failed.
        :param message: the input string that needs to be sent to another user
        :param recipient: the user&#39;s name
        :return: success, which indicates if the sending is successful
        &#34;&#34;&#34;
        # join first to set self.token
        self.join(self.sock, self.username, self.password)
        success = self.send_dm(self.sock, message, recipient)
        return success

    def join(self, sock: socket, username, password) -&gt; None:
        &#34;&#34;&#34;
        Joins the server and feed the retrieved token back to self.token
        :param sock: currently working socket
        :param username: username of current user
        :param password: password of current user
        :return: None
        &#34;&#34;&#34;
        join_msg = self.protocol.send_join_processor(username, password)
        self.protocol.sender(sock, join_msg)
        self.token = self.protocol.response(sock).token

    def send_dm(self, sock: socket, message: str, recipient: str) -&gt; bool:
        &#34;&#34;&#34;
        Wraps up message and recipient into a DirectMessage and send it
        :param sock: currently working socket
        :param message: the input string that needs to be sent to another user
        :param recipient: the user&#39;s name
        :return: a bool indicates if the sending is successful
        &#34;&#34;&#34;

        dm = DirectMessage()
        dm.set_message(message)
        dm.set_recipient(recipient)

        message = self.protocol.send_directmessage_processor(self.token, dm)
        self.protocol.sender(sock, message)

        response = self.protocol.response(sock)
        if response.type == &#39;ok&#39;:
            return True
        else:
            return False

    def retrieve_new(self) -&gt; list:
        &#34;&#34;&#34;
        Returns a list of DirectMessage objects containing all new messages
        :return: a list of DirectMessage objects containing all new messages
        &#34;&#34;&#34;

        # make sure self.token is filled with the correct data
        self.join(self.sock, self.username, self.password)

        msg = self.protocol.request_unread_processor(self.token)
        self.protocol.sender(self.sock, msg)

        dm_list = self.protocol.response(self.sock).message

        return dm_list

    def retrieve_all(self) -&gt; list:
        &#34;&#34;&#34;
        Returns a list of DirectMessage objects containing all messages
        :return: a list of DirectMessage objects containing all messages
        &#34;&#34;&#34;

        # make sure self.token is filled with the correct data
        self.join(self.sock, self.username, self.password)

        msg = self.protocol.request_all_processor(self.token)
        self.protocol.sender(self.sock, msg)

        dm_list = self.protocol.response(self.sock).message

        return dm_list


class DMProtocol:
    &#34;&#34;&#34;
    A protocol class works collaboratively with DirectMessenger class.
    It can also be modified to support other uses of server communication.
    &#34;&#34;&#34;
    def __init__(self):
        pass

    def sender(self, sock: socket, msg: str) -&gt; None:
        &#34;&#34;&#34;
        A wrapper method to simplify the sending process.
        :param sock: currently working socket
        :param msg: the message needs to be sent
        :return: None
        &#34;&#34;&#34;
        send = sock.makefile(&#39;w&#39;)
        send.write(msg + &#39;\r\n&#39;)
        send.flush()

    def extract_json(self, json_msg: str) -&gt; DataTuple:
        &#34;&#34;&#34;
        Call the json.loads function on a JSON string and convert it to a DataTuple object
        :param json_msg: the input JSON str
        :return: the DataTuple object contains json_msg&#39;s information
        &#34;&#34;&#34;
        try:
            type_list = [&#39;error&#39;, &#39;ok&#39;]

            json_obj = json.loads(json_msg)

            # make sure the type is either ok or error
            if json_obj[&#39;response&#39;][&#39;type&#39;] not in type_list:
                raise ValueError(&#39;Type is not ok or error.&#39;)

            type_ = json_obj[&#39;response&#39;][&#39;type&#39;]

            # either &#39;message&#39; or &#39;messages&#39; will be returned from the server
            if &#39;message&#39; in json_obj[&#39;response&#39;]:
                # message here is a str from server
                message = json_obj[&#39;response&#39;][&#39;message&#39;]
            elif &#39;messages&#39; in json_obj[&#39;response&#39;]:
                # message here is a list of DirectMessage
                message = json_obj[&#39;response&#39;][&#39;messages&#39;]

            # when token is present for ok response
            if &#39;token&#39; in json_obj[&#39;response&#39;]:
                token = json_obj[&#39;response&#39;][&#39;token&#39;]
            # when token is not present for error response
            else:
                token = &#39;&#39;

        except json.JSONDecodeError:
            print(&#34;Json cannot be decoded.&#34;)
        except KeyError as e:
            print(&#34;Non-standard response received.&#34;)
        except ValueError as e:
            print(e)
        else:
            return DataTuple(type_, message, token)

    def response(self, sock: socket) -&gt; DataTuple:
        &#34;&#34;&#34;
        It listens the raw response from the server at sock and convert them
        to user friendly messages.
        :param sock: current working socket
        :return: a DataTuple that contains the info from the server
        response JSON
        &#34;&#34;&#34;
        recv = sock.makefile(&#39;r&#39;)
        resp = recv.readline()
        resp = self.extract_json(resp)

        # DataTuple conversion
        if resp.type == &#39;ok&#39;:
            # when sending DirectMessage
            if type(resp.message) is str:

                if &#39;Direct message sent&#39; in resp.message:
                    print(&#34;Direct message successfully sent.&#34;)
                    print(&#39;Server says: {}\n&#39;.format(resp.message))

            # when retrieving DirectMessage
            elif type(resp.message) is list:
                print(&#39;Messages successfully retrieved!&#39;)

        elif resp.type == &#39;error&#39;:
            print(&#34;An error occurs.&#34;)
            print(&#39;Error message: {}\n&#39;.format(resp.message))
        return resp

    def send_join_processor(self, username, password, token=&#39;&#39;) -&gt; str:
        &#34;&#34;&#34;
        Process the inputs username password and token, and make them
        into a JSON string.

        Send format:
        {&#34;join&#34;: {&#34;username&#34;: &#34;ohhimark&#34;, &#34;password&#34;: &#34;password123&#34;, &#34;token&#34;: &#34;user_token&#34;}}

        :param username: the username of the user
        :param password: the password of the user
        :param token: the token that you want to verify with the server
        :return: the formatted JSON string to server
        &#34;&#34;&#34;
        output = &#39;{{&#34;join&#34;: {{&#34;username&#34;: &#34;{0}&#34;, &#34;password&#34;: &#34;{1}&#34;, &#34;token&#34;: &#34;{2}&#34;}}}}&#39;. \
            format(username, password, token)
        return output

    def send_directmessage_processor(self, token, dm: DirectMessage) -&gt; str:
        &#34;&#34;&#34;
        Process the inputs token and dm, and make them
        into a JSON string.

        Send format:
        {&#34;token&#34;:&#34;user_token&#34;, &#34;directmessage&#34;: {&#34;entry&#34;: &#34;Hello World!&#34;,&#34;recipient&#34;:&#34;ohhimark&#34;, &#34;timestamp&#34;: &#34;1603167689.3928561&#34;}}

        :param token: the token of this message&#39;s sender
        :param dm: the DirectMessage object that needs to be sent
        :return: the formatted JSON string to server
        &#34;&#34;&#34;
        entry = dm.get_message()
        recipient = dm.get_recipient()

        # set the timestamp when sending the message, it shows when the message was originally sent
        timestamp = time.time()
        dm.set_timestamp(timestamp)
        timestamp = dm.get_timestamp()

        output = &#39;{{&#34;token&#34;: &#34;{0}&#34;, &#34;directmessage&#34;: {{&#34;entry&#34;: &#34;{1}&#34;, &#34;recipient&#34;: &#34;{2}&#34;, &#34;timestamp&#34;: &#34;{3}&#34;}}}}&#39;.\
            format(token, entry, recipient, timestamp)
        return output

    def request_unread_processor(self, token) -&gt; str:
        &#34;&#34;&#34;
        Process the inputs token, and make it into a JSON string.

        Request format:
        {&#34;token&#34;:&#34;user_token&#34;, &#34;directmessage&#34;: &#34;new&#34;}

        :param token: the token of this message&#39;s sender
        :return: the formatted JSON string to server
        &#34;&#34;&#34;
        output = &#39;{{&#34;token&#34;: &#34;{0}&#34;, &#34;directmessage&#34;: &#34;new&#34;}}&#39;.format(token)
        return output

    def request_all_processor(self, token) -&gt; str:
        &#34;&#34;&#34;
        Process the inputs token, and make it into a JSON string.

        Request format:
        {&#34;token&#34;:&#34;user_token&#34;, &#34;directmessage&#34;: &#34;all&#34;}

        :param token: the token of this message&#39;s sender
        :return: the formatted JSON string to server
        &#34;&#34;&#34;
        output = &#39;{{&#34;token&#34;: &#34;{0}&#34;, &#34;directmessage&#34;: &#34;all&#34;}}&#39;.format(token)
        return output


if __name__ == &#39;__main__&#39;:

    # for test usage, run and see what happens!

    sender_dsuserver = HOST
    sender_username = &#39;The_Group_Sender&#39;
    sender_password = &#39;The_Group_Sender_password&#39;
    sender = DirectMessenger(sender_dsuserver, sender_username, sender_password)

    print(&#34;Should print out True if successfully sent:&#34;)
    print(sender.send(&#39;something nice&#39;, &#39;The_Group_Receiver&#39;))

    print()

    receiver_username = &#39;The_Group_Receiver&#39;
    receiver_password = &#39;The_Group_Receiver_password&#39;
    receiver_dsuserver = HOST
    receiver = DirectMessenger(receiver_dsuserver, receiver_username, receiver_password)

    print(&#34;receiver&#39;s new messages:&#34;)
    print(receiver.retrieve_new())

    print()

    print(&#34;receiver&#39;s all messages:&#34;)
    print(receiver.retrieve_all())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ds_messenger.DMProtocol"><code class="flex name class">
<span>class <span class="ident">DMProtocol</span></span>
</code></dt>
<dd>
<div class="desc"><p>A protocol class works collaboratively with DirectMessenger class.
It can also be modified to support other uses of server communication.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DMProtocol:
    &#34;&#34;&#34;
    A protocol class works collaboratively with DirectMessenger class.
    It can also be modified to support other uses of server communication.
    &#34;&#34;&#34;
    def __init__(self):
        pass

    def sender(self, sock: socket, msg: str) -&gt; None:
        &#34;&#34;&#34;
        A wrapper method to simplify the sending process.
        :param sock: currently working socket
        :param msg: the message needs to be sent
        :return: None
        &#34;&#34;&#34;
        send = sock.makefile(&#39;w&#39;)
        send.write(msg + &#39;\r\n&#39;)
        send.flush()

    def extract_json(self, json_msg: str) -&gt; DataTuple:
        &#34;&#34;&#34;
        Call the json.loads function on a JSON string and convert it to a DataTuple object
        :param json_msg: the input JSON str
        :return: the DataTuple object contains json_msg&#39;s information
        &#34;&#34;&#34;
        try:
            type_list = [&#39;error&#39;, &#39;ok&#39;]

            json_obj = json.loads(json_msg)

            # make sure the type is either ok or error
            if json_obj[&#39;response&#39;][&#39;type&#39;] not in type_list:
                raise ValueError(&#39;Type is not ok or error.&#39;)

            type_ = json_obj[&#39;response&#39;][&#39;type&#39;]

            # either &#39;message&#39; or &#39;messages&#39; will be returned from the server
            if &#39;message&#39; in json_obj[&#39;response&#39;]:
                # message here is a str from server
                message = json_obj[&#39;response&#39;][&#39;message&#39;]
            elif &#39;messages&#39; in json_obj[&#39;response&#39;]:
                # message here is a list of DirectMessage
                message = json_obj[&#39;response&#39;][&#39;messages&#39;]

            # when token is present for ok response
            if &#39;token&#39; in json_obj[&#39;response&#39;]:
                token = json_obj[&#39;response&#39;][&#39;token&#39;]
            # when token is not present for error response
            else:
                token = &#39;&#39;

        except json.JSONDecodeError:
            print(&#34;Json cannot be decoded.&#34;)
        except KeyError as e:
            print(&#34;Non-standard response received.&#34;)
        except ValueError as e:
            print(e)
        else:
            return DataTuple(type_, message, token)

    def response(self, sock: socket) -&gt; DataTuple:
        &#34;&#34;&#34;
        It listens the raw response from the server at sock and convert them
        to user friendly messages.
        :param sock: current working socket
        :return: a DataTuple that contains the info from the server
        response JSON
        &#34;&#34;&#34;
        recv = sock.makefile(&#39;r&#39;)
        resp = recv.readline()
        resp = self.extract_json(resp)

        # DataTuple conversion
        if resp.type == &#39;ok&#39;:
            # when sending DirectMessage
            if type(resp.message) is str:

                if &#39;Direct message sent&#39; in resp.message:
                    print(&#34;Direct message successfully sent.&#34;)
                    print(&#39;Server says: {}\n&#39;.format(resp.message))

            # when retrieving DirectMessage
            elif type(resp.message) is list:
                print(&#39;Messages successfully retrieved!&#39;)

        elif resp.type == &#39;error&#39;:
            print(&#34;An error occurs.&#34;)
            print(&#39;Error message: {}\n&#39;.format(resp.message))
        return resp

    def send_join_processor(self, username, password, token=&#39;&#39;) -&gt; str:
        &#34;&#34;&#34;
        Process the inputs username password and token, and make them
        into a JSON string.

        Send format:
        {&#34;join&#34;: {&#34;username&#34;: &#34;ohhimark&#34;, &#34;password&#34;: &#34;password123&#34;, &#34;token&#34;: &#34;user_token&#34;}}

        :param username: the username of the user
        :param password: the password of the user
        :param token: the token that you want to verify with the server
        :return: the formatted JSON string to server
        &#34;&#34;&#34;
        output = &#39;{{&#34;join&#34;: {{&#34;username&#34;: &#34;{0}&#34;, &#34;password&#34;: &#34;{1}&#34;, &#34;token&#34;: &#34;{2}&#34;}}}}&#39;. \
            format(username, password, token)
        return output

    def send_directmessage_processor(self, token, dm: DirectMessage) -&gt; str:
        &#34;&#34;&#34;
        Process the inputs token and dm, and make them
        into a JSON string.

        Send format:
        {&#34;token&#34;:&#34;user_token&#34;, &#34;directmessage&#34;: {&#34;entry&#34;: &#34;Hello World!&#34;,&#34;recipient&#34;:&#34;ohhimark&#34;, &#34;timestamp&#34;: &#34;1603167689.3928561&#34;}}

        :param token: the token of this message&#39;s sender
        :param dm: the DirectMessage object that needs to be sent
        :return: the formatted JSON string to server
        &#34;&#34;&#34;
        entry = dm.get_message()
        recipient = dm.get_recipient()

        # set the timestamp when sending the message, it shows when the message was originally sent
        timestamp = time.time()
        dm.set_timestamp(timestamp)
        timestamp = dm.get_timestamp()

        output = &#39;{{&#34;token&#34;: &#34;{0}&#34;, &#34;directmessage&#34;: {{&#34;entry&#34;: &#34;{1}&#34;, &#34;recipient&#34;: &#34;{2}&#34;, &#34;timestamp&#34;: &#34;{3}&#34;}}}}&#39;.\
            format(token, entry, recipient, timestamp)
        return output

    def request_unread_processor(self, token) -&gt; str:
        &#34;&#34;&#34;
        Process the inputs token, and make it into a JSON string.

        Request format:
        {&#34;token&#34;:&#34;user_token&#34;, &#34;directmessage&#34;: &#34;new&#34;}

        :param token: the token of this message&#39;s sender
        :return: the formatted JSON string to server
        &#34;&#34;&#34;
        output = &#39;{{&#34;token&#34;: &#34;{0}&#34;, &#34;directmessage&#34;: &#34;new&#34;}}&#39;.format(token)
        return output

    def request_all_processor(self, token) -&gt; str:
        &#34;&#34;&#34;
        Process the inputs token, and make it into a JSON string.

        Request format:
        {&#34;token&#34;:&#34;user_token&#34;, &#34;directmessage&#34;: &#34;all&#34;}

        :param token: the token of this message&#39;s sender
        :return: the formatted JSON string to server
        &#34;&#34;&#34;
        output = &#39;{{&#34;token&#34;: &#34;{0}&#34;, &#34;directmessage&#34;: &#34;all&#34;}}&#39;.format(token)
        return output</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ds_messenger.DMProtocol.extract_json"><code class="name flex">
<span>def <span class="ident">extract_json</span></span>(<span>self, json_msg: str) ‑> <a title="ds_messenger.DataTuple" href="#ds_messenger.DataTuple">DataTuple</a></span>
</code></dt>
<dd>
<div class="desc"><p>Call the json.loads function on a JSON string and convert it to a DataTuple object
:param json_msg: the input JSON str
:return: the DataTuple object contains json_msg's information</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_json(self, json_msg: str) -&gt; DataTuple:
    &#34;&#34;&#34;
    Call the json.loads function on a JSON string and convert it to a DataTuple object
    :param json_msg: the input JSON str
    :return: the DataTuple object contains json_msg&#39;s information
    &#34;&#34;&#34;
    try:
        type_list = [&#39;error&#39;, &#39;ok&#39;]

        json_obj = json.loads(json_msg)

        # make sure the type is either ok or error
        if json_obj[&#39;response&#39;][&#39;type&#39;] not in type_list:
            raise ValueError(&#39;Type is not ok or error.&#39;)

        type_ = json_obj[&#39;response&#39;][&#39;type&#39;]

        # either &#39;message&#39; or &#39;messages&#39; will be returned from the server
        if &#39;message&#39; in json_obj[&#39;response&#39;]:
            # message here is a str from server
            message = json_obj[&#39;response&#39;][&#39;message&#39;]
        elif &#39;messages&#39; in json_obj[&#39;response&#39;]:
            # message here is a list of DirectMessage
            message = json_obj[&#39;response&#39;][&#39;messages&#39;]

        # when token is present for ok response
        if &#39;token&#39; in json_obj[&#39;response&#39;]:
            token = json_obj[&#39;response&#39;][&#39;token&#39;]
        # when token is not present for error response
        else:
            token = &#39;&#39;

    except json.JSONDecodeError:
        print(&#34;Json cannot be decoded.&#34;)
    except KeyError as e:
        print(&#34;Non-standard response received.&#34;)
    except ValueError as e:
        print(e)
    else:
        return DataTuple(type_, message, token)</code></pre>
</details>
</dd>
<dt id="ds_messenger.DMProtocol.request_all_processor"><code class="name flex">
<span>def <span class="ident">request_all_processor</span></span>(<span>self, token) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Process the inputs token, and make it into a JSON string.</p>
<p _all_="&quot;all&quot;" _directmessage_:="&quot;directmessage&quot;:" _token_:_user_token_="&quot;token&quot;:&quot;user_token&quot;,">Request format:</p>
<p>:param token: the token of this message's sender
:return: the formatted JSON string to server</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def request_all_processor(self, token) -&gt; str:
    &#34;&#34;&#34;
    Process the inputs token, and make it into a JSON string.

    Request format:
    {&#34;token&#34;:&#34;user_token&#34;, &#34;directmessage&#34;: &#34;all&#34;}

    :param token: the token of this message&#39;s sender
    :return: the formatted JSON string to server
    &#34;&#34;&#34;
    output = &#39;{{&#34;token&#34;: &#34;{0}&#34;, &#34;directmessage&#34;: &#34;all&#34;}}&#39;.format(token)
    return output</code></pre>
</details>
</dd>
<dt id="ds_messenger.DMProtocol.request_unread_processor"><code class="name flex">
<span>def <span class="ident">request_unread_processor</span></span>(<span>self, token) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Process the inputs token, and make it into a JSON string.</p>
<p _directmessage_:="&quot;directmessage&quot;:" _new_="&quot;new&quot;" _token_:_user_token_="&quot;token&quot;:&quot;user_token&quot;,">Request format:</p>
<p>:param token: the token of this message's sender
:return: the formatted JSON string to server</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def request_unread_processor(self, token) -&gt; str:
    &#34;&#34;&#34;
    Process the inputs token, and make it into a JSON string.

    Request format:
    {&#34;token&#34;:&#34;user_token&#34;, &#34;directmessage&#34;: &#34;new&#34;}

    :param token: the token of this message&#39;s sender
    :return: the formatted JSON string to server
    &#34;&#34;&#34;
    output = &#39;{{&#34;token&#34;: &#34;{0}&#34;, &#34;directmessage&#34;: &#34;new&#34;}}&#39;.format(token)
    return output</code></pre>
</details>
</dd>
<dt id="ds_messenger.DMProtocol.response"><code class="name flex">
<span>def <span class="ident">response</span></span>(<span>self, sock: <module 'socket' from 'c:\\users\\thinkpad\\appdata\\local\\programs\\python\\python36-32\\lib\\socket.py'>) ‑> <a title="ds_messenger.DataTuple" href="#ds_messenger.DataTuple">DataTuple</a></span>
</code></dt>
<dd>
<div class="desc"><p>It listens the raw response from the server at sock and convert them
to user friendly messages.
:param sock: current working socket
:return: a DataTuple that contains the info from the server
response JSON</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def response(self, sock: socket) -&gt; DataTuple:
    &#34;&#34;&#34;
    It listens the raw response from the server at sock and convert them
    to user friendly messages.
    :param sock: current working socket
    :return: a DataTuple that contains the info from the server
    response JSON
    &#34;&#34;&#34;
    recv = sock.makefile(&#39;r&#39;)
    resp = recv.readline()
    resp = self.extract_json(resp)

    # DataTuple conversion
    if resp.type == &#39;ok&#39;:
        # when sending DirectMessage
        if type(resp.message) is str:

            if &#39;Direct message sent&#39; in resp.message:
                print(&#34;Direct message successfully sent.&#34;)
                print(&#39;Server says: {}\n&#39;.format(resp.message))

        # when retrieving DirectMessage
        elif type(resp.message) is list:
            print(&#39;Messages successfully retrieved!&#39;)

    elif resp.type == &#39;error&#39;:
        print(&#34;An error occurs.&#34;)
        print(&#39;Error message: {}\n&#39;.format(resp.message))
    return resp</code></pre>
</details>
</dd>
<dt id="ds_messenger.DMProtocol.send_directmessage_processor"><code class="name flex">
<span>def <span class="ident">send_directmessage_processor</span></span>(<span>self, token, dm: <a title="ds_messenger.DirectMessage" href="#ds_messenger.DirectMessage">DirectMessage</a>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Process the inputs token and dm, and make them
into a JSON string.</p>
<p>Send format:
{"token":"user_token", "directmessage": {"entry": "Hello World!","recipient":"ohhimark", "timestamp": "1603167689.3928561"}}</p>
<p>:param token: the token of this message's sender
:param dm: the DirectMessage object that needs to be sent
:return: the formatted JSON string to server</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_directmessage_processor(self, token, dm: DirectMessage) -&gt; str:
    &#34;&#34;&#34;
    Process the inputs token and dm, and make them
    into a JSON string.

    Send format:
    {&#34;token&#34;:&#34;user_token&#34;, &#34;directmessage&#34;: {&#34;entry&#34;: &#34;Hello World!&#34;,&#34;recipient&#34;:&#34;ohhimark&#34;, &#34;timestamp&#34;: &#34;1603167689.3928561&#34;}}

    :param token: the token of this message&#39;s sender
    :param dm: the DirectMessage object that needs to be sent
    :return: the formatted JSON string to server
    &#34;&#34;&#34;
    entry = dm.get_message()
    recipient = dm.get_recipient()

    # set the timestamp when sending the message, it shows when the message was originally sent
    timestamp = time.time()
    dm.set_timestamp(timestamp)
    timestamp = dm.get_timestamp()

    output = &#39;{{&#34;token&#34;: &#34;{0}&#34;, &#34;directmessage&#34;: {{&#34;entry&#34;: &#34;{1}&#34;, &#34;recipient&#34;: &#34;{2}&#34;, &#34;timestamp&#34;: &#34;{3}&#34;}}}}&#39;.\
        format(token, entry, recipient, timestamp)
    return output</code></pre>
</details>
</dd>
<dt id="ds_messenger.DMProtocol.send_join_processor"><code class="name flex">
<span>def <span class="ident">send_join_processor</span></span>(<span>self, username, password, token='') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Process the inputs username password and token, and make them
into a JSON string.</p>
<p>Send format:
{"join": {"username": "ohhimark", "password": "password123", "token": "user_token"}}</p>
<p>:param username: the username of the user
:param password: the password of the user
:param token: the token that you want to verify with the server
:return: the formatted JSON string to server</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_join_processor(self, username, password, token=&#39;&#39;) -&gt; str:
    &#34;&#34;&#34;
    Process the inputs username password and token, and make them
    into a JSON string.

    Send format:
    {&#34;join&#34;: {&#34;username&#34;: &#34;ohhimark&#34;, &#34;password&#34;: &#34;password123&#34;, &#34;token&#34;: &#34;user_token&#34;}}

    :param username: the username of the user
    :param password: the password of the user
    :param token: the token that you want to verify with the server
    :return: the formatted JSON string to server
    &#34;&#34;&#34;
    output = &#39;{{&#34;join&#34;: {{&#34;username&#34;: &#34;{0}&#34;, &#34;password&#34;: &#34;{1}&#34;, &#34;token&#34;: &#34;{2}&#34;}}}}&#39;. \
        format(username, password, token)
    return output</code></pre>
</details>
</dd>
<dt id="ds_messenger.DMProtocol.sender"><code class="name flex">
<span>def <span class="ident">sender</span></span>(<span>self, sock: <module 'socket' from 'c:\\users\\thinkpad\\appdata\\local\\programs\\python\\python36-32\\lib\\socket.py'>, msg: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>A wrapper method to simplify the sending process.
:param sock: currently working socket
:param msg: the message needs to be sent
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sender(self, sock: socket, msg: str) -&gt; None:
    &#34;&#34;&#34;
    A wrapper method to simplify the sending process.
    :param sock: currently working socket
    :param msg: the message needs to be sent
    :return: None
    &#34;&#34;&#34;
    send = sock.makefile(&#39;w&#39;)
    send.write(msg + &#39;\r\n&#39;)
    send.flush()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ds_messenger.DMProtocolError"><code class="flex name class">
<span>class <span class="ident">DMProtocolError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom error class for DMProtocolError</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DMProtocolError(Exception):
    &#34;&#34;&#34;
    Custom error class for DMProtocolError
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="ds_messenger.DataTuple"><code class="flex name class">
<span>class <span class="ident">DataTuple</span></span>
<span>(</span><span>type, message, token)</span>
</code></dt>
<dd>
<div class="desc"><p>DataTuple(type, message, token)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="ds_messenger.DataTuple.message"><code class="name">var <span class="ident">message</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="ds_messenger.DataTuple.token"><code class="name">var <span class="ident">token</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="ds_messenger.DataTuple.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
</dl>
</dd>
<dt id="ds_messenger.DirectMessage"><code class="flex name class">
<span>class <span class="ident">DirectMessage</span></span>
</code></dt>
<dd>
<div class="desc"><p>The DirectMessage object using in sending messages.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DirectMessage:
    &#34;&#34;&#34;
    The DirectMessage object using in sending messages.
    &#34;&#34;&#34;
    def __init__(self):
        self.recipient = None
        self.message = None
        self.timestamp = None

    def get_recipient(self):
        &#34;&#34;&#34;
        Get self.recipient
        :return: self.recipient
        &#34;&#34;&#34;
        return self.recipient

    def get_message(self):
        &#34;&#34;&#34;
        Get self.message
        :return: self.message
        &#34;&#34;&#34;
        return self.message

    def get_timestamp(self):
        &#34;&#34;&#34;
        Get self.timestamp
        :return: self.timestamp
        &#34;&#34;&#34;
        return self.timestamp

    def set_recipient(self, name) -&gt; None:
        &#34;&#34;&#34;
        Set self.recipient
        :return: None
        &#34;&#34;&#34;
        self.recipient = name

    def set_message(self, msg) -&gt; None:
        &#34;&#34;&#34;
        Set self.message
        :return: None
        &#34;&#34;&#34;
        self.message = msg

    def set_timestamp(self, time) -&gt; None:
        &#34;&#34;&#34;
        Set self.timestamp
        :return: None
        &#34;&#34;&#34;
        self.timestamp = time</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ds_messenger.DirectMessage.get_message"><code class="name flex">
<span>def <span class="ident">get_message</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get self.message
:return: self.message</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_message(self):
    &#34;&#34;&#34;
    Get self.message
    :return: self.message
    &#34;&#34;&#34;
    return self.message</code></pre>
</details>
</dd>
<dt id="ds_messenger.DirectMessage.get_recipient"><code class="name flex">
<span>def <span class="ident">get_recipient</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get self.recipient
:return: self.recipient</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_recipient(self):
    &#34;&#34;&#34;
    Get self.recipient
    :return: self.recipient
    &#34;&#34;&#34;
    return self.recipient</code></pre>
</details>
</dd>
<dt id="ds_messenger.DirectMessage.get_timestamp"><code class="name flex">
<span>def <span class="ident">get_timestamp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get self.timestamp
:return: self.timestamp</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_timestamp(self):
    &#34;&#34;&#34;
    Get self.timestamp
    :return: self.timestamp
    &#34;&#34;&#34;
    return self.timestamp</code></pre>
</details>
</dd>
<dt id="ds_messenger.DirectMessage.set_message"><code class="name flex">
<span>def <span class="ident">set_message</span></span>(<span>self, msg) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Set self.message
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_message(self, msg) -&gt; None:
    &#34;&#34;&#34;
    Set self.message
    :return: None
    &#34;&#34;&#34;
    self.message = msg</code></pre>
</details>
</dd>
<dt id="ds_messenger.DirectMessage.set_recipient"><code class="name flex">
<span>def <span class="ident">set_recipient</span></span>(<span>self, name) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Set self.recipient
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_recipient(self, name) -&gt; None:
    &#34;&#34;&#34;
    Set self.recipient
    :return: None
    &#34;&#34;&#34;
    self.recipient = name</code></pre>
</details>
</dd>
<dt id="ds_messenger.DirectMessage.set_timestamp"><code class="name flex">
<span>def <span class="ident">set_timestamp</span></span>(<span>self, time) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Set self.timestamp
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_timestamp(self, time) -&gt; None:
    &#34;&#34;&#34;
    Set self.timestamp
    :return: None
    &#34;&#34;&#34;
    self.timestamp = time</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ds_messenger.DirectMessenger"><code class="flex name class">
<span>class <span class="ident">DirectMessenger</span></span>
<span>(</span><span>dsuserver: str = None, username: str = None, password: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>The class responsible for sending and receiving messages to and from another
user.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DirectMessenger:
    &#34;&#34;&#34;
    The class responsible for sending and receiving messages to and from another
    user.
    &#34;&#34;&#34;
    def __init__(self, dsuserver: str = None, username: str = None, password: str = None):
        self.token = None
        self.dsuserver = dsuserver
        self.username = username
        self.password = password
        # DMProtocol for usage
        self.protocol = DMProtocol()
        # Initialize the sock along with the DirectMessenger object
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            self.sock.connect((str(self.dsuserver), PORT))
        except socket.gaierror as e:
            msg = &#39;The address or port seems incorrect&#39;
            raise DirectMessengerError(msg) from e

    def send(self, message: str, recipient: str) -&gt; bool:
        &#34;&#34;&#34;
        Send the message to the specified recipient.
        Returns true if message successfully sent, false if send failed.
        :param message: the input string that needs to be sent to another user
        :param recipient: the user&#39;s name
        :return: success, which indicates if the sending is successful
        &#34;&#34;&#34;
        # join first to set self.token
        self.join(self.sock, self.username, self.password)
        success = self.send_dm(self.sock, message, recipient)
        return success

    def join(self, sock: socket, username, password) -&gt; None:
        &#34;&#34;&#34;
        Joins the server and feed the retrieved token back to self.token
        :param sock: currently working socket
        :param username: username of current user
        :param password: password of current user
        :return: None
        &#34;&#34;&#34;
        join_msg = self.protocol.send_join_processor(username, password)
        self.protocol.sender(sock, join_msg)
        self.token = self.protocol.response(sock).token

    def send_dm(self, sock: socket, message: str, recipient: str) -&gt; bool:
        &#34;&#34;&#34;
        Wraps up message and recipient into a DirectMessage and send it
        :param sock: currently working socket
        :param message: the input string that needs to be sent to another user
        :param recipient: the user&#39;s name
        :return: a bool indicates if the sending is successful
        &#34;&#34;&#34;

        dm = DirectMessage()
        dm.set_message(message)
        dm.set_recipient(recipient)

        message = self.protocol.send_directmessage_processor(self.token, dm)
        self.protocol.sender(sock, message)

        response = self.protocol.response(sock)
        if response.type == &#39;ok&#39;:
            return True
        else:
            return False

    def retrieve_new(self) -&gt; list:
        &#34;&#34;&#34;
        Returns a list of DirectMessage objects containing all new messages
        :return: a list of DirectMessage objects containing all new messages
        &#34;&#34;&#34;

        # make sure self.token is filled with the correct data
        self.join(self.sock, self.username, self.password)

        msg = self.protocol.request_unread_processor(self.token)
        self.protocol.sender(self.sock, msg)

        dm_list = self.protocol.response(self.sock).message

        return dm_list

    def retrieve_all(self) -&gt; list:
        &#34;&#34;&#34;
        Returns a list of DirectMessage objects containing all messages
        :return: a list of DirectMessage objects containing all messages
        &#34;&#34;&#34;

        # make sure self.token is filled with the correct data
        self.join(self.sock, self.username, self.password)

        msg = self.protocol.request_all_processor(self.token)
        self.protocol.sender(self.sock, msg)

        dm_list = self.protocol.response(self.sock).message

        return dm_list</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ds_messenger.DirectMessenger.join"><code class="name flex">
<span>def <span class="ident">join</span></span>(<span>self, sock: <module 'socket' from 'c:\\users\\thinkpad\\appdata\\local\\programs\\python\\python36-32\\lib\\socket.py'>, username, password) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Joins the server and feed the retrieved token back to self.token
:param sock: currently working socket
:param username: username of current user
:param password: password of current user
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join(self, sock: socket, username, password) -&gt; None:
    &#34;&#34;&#34;
    Joins the server and feed the retrieved token back to self.token
    :param sock: currently working socket
    :param username: username of current user
    :param password: password of current user
    :return: None
    &#34;&#34;&#34;
    join_msg = self.protocol.send_join_processor(username, password)
    self.protocol.sender(sock, join_msg)
    self.token = self.protocol.response(sock).token</code></pre>
</details>
</dd>
<dt id="ds_messenger.DirectMessenger.retrieve_all"><code class="name flex">
<span>def <span class="ident">retrieve_all</span></span>(<span>self) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of DirectMessage objects containing all messages
:return: a list of DirectMessage objects containing all messages</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieve_all(self) -&gt; list:
    &#34;&#34;&#34;
    Returns a list of DirectMessage objects containing all messages
    :return: a list of DirectMessage objects containing all messages
    &#34;&#34;&#34;

    # make sure self.token is filled with the correct data
    self.join(self.sock, self.username, self.password)

    msg = self.protocol.request_all_processor(self.token)
    self.protocol.sender(self.sock, msg)

    dm_list = self.protocol.response(self.sock).message

    return dm_list</code></pre>
</details>
</dd>
<dt id="ds_messenger.DirectMessenger.retrieve_new"><code class="name flex">
<span>def <span class="ident">retrieve_new</span></span>(<span>self) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of DirectMessage objects containing all new messages
:return: a list of DirectMessage objects containing all new messages</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieve_new(self) -&gt; list:
    &#34;&#34;&#34;
    Returns a list of DirectMessage objects containing all new messages
    :return: a list of DirectMessage objects containing all new messages
    &#34;&#34;&#34;

    # make sure self.token is filled with the correct data
    self.join(self.sock, self.username, self.password)

    msg = self.protocol.request_unread_processor(self.token)
    self.protocol.sender(self.sock, msg)

    dm_list = self.protocol.response(self.sock).message

    return dm_list</code></pre>
</details>
</dd>
<dt id="ds_messenger.DirectMessenger.send"><code class="name flex">
<span>def <span class="ident">send</span></span>(<span>self, message: str, recipient: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Send the message to the specified recipient.
Returns true if message successfully sent, false if send failed.
:param message: the input string that needs to be sent to another user
:param recipient: the user's name
:return: success, which indicates if the sending is successful</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send(self, message: str, recipient: str) -&gt; bool:
    &#34;&#34;&#34;
    Send the message to the specified recipient.
    Returns true if message successfully sent, false if send failed.
    :param message: the input string that needs to be sent to another user
    :param recipient: the user&#39;s name
    :return: success, which indicates if the sending is successful
    &#34;&#34;&#34;
    # join first to set self.token
    self.join(self.sock, self.username, self.password)
    success = self.send_dm(self.sock, message, recipient)
    return success</code></pre>
</details>
</dd>
<dt id="ds_messenger.DirectMessenger.send_dm"><code class="name flex">
<span>def <span class="ident">send_dm</span></span>(<span>self, sock: <module 'socket' from 'c:\\users\\thinkpad\\appdata\\local\\programs\\python\\python36-32\\lib\\socket.py'>, message: str, recipient: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Wraps up message and recipient into a DirectMessage and send it
:param sock: currently working socket
:param message: the input string that needs to be sent to another user
:param recipient: the user's name
:return: a bool indicates if the sending is successful</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_dm(self, sock: socket, message: str, recipient: str) -&gt; bool:
    &#34;&#34;&#34;
    Wraps up message and recipient into a DirectMessage and send it
    :param sock: currently working socket
    :param message: the input string that needs to be sent to another user
    :param recipient: the user&#39;s name
    :return: a bool indicates if the sending is successful
    &#34;&#34;&#34;

    dm = DirectMessage()
    dm.set_message(message)
    dm.set_recipient(recipient)

    message = self.protocol.send_directmessage_processor(self.token, dm)
    self.protocol.sender(sock, message)

    response = self.protocol.response(sock)
    if response.type == &#39;ok&#39;:
        return True
    else:
        return False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ds_messenger.DirectMessengerError"><code class="flex name class">
<span>class <span class="ident">DirectMessengerError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom error class for DirectMessenger</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DirectMessengerError(Exception):
    &#34;&#34;&#34;
    Custom error class for DirectMessenger
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ds_messenger.DMProtocol" href="#ds_messenger.DMProtocol">DMProtocol</a></code></h4>
<ul class="">
<li><code><a title="ds_messenger.DMProtocol.extract_json" href="#ds_messenger.DMProtocol.extract_json">extract_json</a></code></li>
<li><code><a title="ds_messenger.DMProtocol.request_all_processor" href="#ds_messenger.DMProtocol.request_all_processor">request_all_processor</a></code></li>
<li><code><a title="ds_messenger.DMProtocol.request_unread_processor" href="#ds_messenger.DMProtocol.request_unread_processor">request_unread_processor</a></code></li>
<li><code><a title="ds_messenger.DMProtocol.response" href="#ds_messenger.DMProtocol.response">response</a></code></li>
<li><code><a title="ds_messenger.DMProtocol.send_directmessage_processor" href="#ds_messenger.DMProtocol.send_directmessage_processor">send_directmessage_processor</a></code></li>
<li><code><a title="ds_messenger.DMProtocol.send_join_processor" href="#ds_messenger.DMProtocol.send_join_processor">send_join_processor</a></code></li>
<li><code><a title="ds_messenger.DMProtocol.sender" href="#ds_messenger.DMProtocol.sender">sender</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ds_messenger.DMProtocolError" href="#ds_messenger.DMProtocolError">DMProtocolError</a></code></h4>
</li>
<li>
<h4><code><a title="ds_messenger.DataTuple" href="#ds_messenger.DataTuple">DataTuple</a></code></h4>
<ul class="">
<li><code><a title="ds_messenger.DataTuple.message" href="#ds_messenger.DataTuple.message">message</a></code></li>
<li><code><a title="ds_messenger.DataTuple.token" href="#ds_messenger.DataTuple.token">token</a></code></li>
<li><code><a title="ds_messenger.DataTuple.type" href="#ds_messenger.DataTuple.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ds_messenger.DirectMessage" href="#ds_messenger.DirectMessage">DirectMessage</a></code></h4>
<ul class="two-column">
<li><code><a title="ds_messenger.DirectMessage.get_message" href="#ds_messenger.DirectMessage.get_message">get_message</a></code></li>
<li><code><a title="ds_messenger.DirectMessage.get_recipient" href="#ds_messenger.DirectMessage.get_recipient">get_recipient</a></code></li>
<li><code><a title="ds_messenger.DirectMessage.get_timestamp" href="#ds_messenger.DirectMessage.get_timestamp">get_timestamp</a></code></li>
<li><code><a title="ds_messenger.DirectMessage.set_message" href="#ds_messenger.DirectMessage.set_message">set_message</a></code></li>
<li><code><a title="ds_messenger.DirectMessage.set_recipient" href="#ds_messenger.DirectMessage.set_recipient">set_recipient</a></code></li>
<li><code><a title="ds_messenger.DirectMessage.set_timestamp" href="#ds_messenger.DirectMessage.set_timestamp">set_timestamp</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ds_messenger.DirectMessenger" href="#ds_messenger.DirectMessenger">DirectMessenger</a></code></h4>
<ul class="">
<li><code><a title="ds_messenger.DirectMessenger.join" href="#ds_messenger.DirectMessenger.join">join</a></code></li>
<li><code><a title="ds_messenger.DirectMessenger.retrieve_all" href="#ds_messenger.DirectMessenger.retrieve_all">retrieve_all</a></code></li>
<li><code><a title="ds_messenger.DirectMessenger.retrieve_new" href="#ds_messenger.DirectMessenger.retrieve_new">retrieve_new</a></code></li>
<li><code><a title="ds_messenger.DirectMessenger.send" href="#ds_messenger.DirectMessenger.send">send</a></code></li>
<li><code><a title="ds_messenger.DirectMessenger.send_dm" href="#ds_messenger.DirectMessenger.send_dm">send_dm</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ds_messenger.DirectMessengerError" href="#ds_messenger.DirectMessengerError">DirectMessengerError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>